

        function tmf(ran)
	Implicit none
	Real tmf,ran  
c       This function chooses a stellar mass from the Miller-Scalo
c       initial mass function.
        tmf=0.19*ran/((1.-ran)**.75+.032*(1.-ran)**.25)
        end

        function lum(em,cm)
         Implicit none
         Real lum,cm,em
c       lum is the luminosity as calcbulated by using the core mass
         lum=(2.d5*cm**6)/(1.d0 + 2.5d0*cm**4 + 3.d0*cm**5) +
     *             (2.2d0*em**3.2d0)
        end

        function cof(ms)
        Implicit none
        Real cof,ms,co0
        cof=10.**(-0.22+0.36*(log10(ms+1.))**2.5)
        end

      FUNCTION ran1(idum)
      INTEGER idum,IA,IM,IQ,IR,NTAB,NDIV
      REAL ran1,AM,EPS,RNMX
      PARAMETER (IA=16807,IM=2147483647,AM=1./IM,IQ=127773,IR=2836,
     *NTAB=32,NDIV=1+(IM-1)/NTAB,EPS=1.2e-7,RNMX=1.-EPS)
      INTEGER j,k,iv(NTAB),iy
      SAVE iv,iy
      DATA iv /NTAB*0/, iy /0/
      if (idum.le.0.or.iy.eq.0) then
        idum=max(-idum,1)
        do 11 j=NTAB+8,1,-1
          k=idum/IQ
          idum=IA*(idum-k*IQ)-IR*k
          if (idum.lt.0) idum=idum+IM
          if (j.le.NTAB) iv(j)=idum
11      continue
        iy=iv(1)
      endif
      k=idum/IQ
      idum=IA*(idum-k*IQ)-IR*k
      if (idum.lt.0) idum=idum+IM
      j=1+iy/NDIV
      iy=iv(j)
      iv(j)=idum
      ran1=min(AM*iy,RNMX)
      return
      END

*******************************************************************************
c       calcbulate the total magnification for a binary lens
c       xs, ys:, source position
c       m1, x1, y1: mass and position for the first lens
c       m2, x2, y2: mass and position for the second lens
c
********************************************************************************





        function mag(xs, ys, x1, y1, x2, y2, m1, m2,nr)
        implicit none
        real*8 mag
        real*8 xs, ys
        real*8 x1, y1, x2, y2
        real*8 m1, m2
        complex*16 z2, z2c
        complex*16 zs, zsc
        complex*16 z, zc
        complex*16 dzs
        integer i, m
        parameter (m=5)
c        common /nroots/ nr
        integer nr

        complex*16 b(m+1), roots(m), delta
c       eps solution error precision (should be larger for large mass ratio)
        real*8 eps
        parameter (eps=1.0d-5)

c       do a translation such that the first lens is at the origin
        zs = dcmplx(xs-x1, ys-y1)
        zsc = dconjg(zs)
        z2 = dcmplx(x2-x1, y2-y1)
        z2c = dconjg(z2)

c
c       polynomial coefficients generated by Mathematica

        b(6) = -zsc**2 + zsc*z2c
        b(5) = -(m1*zsc) - m2*zsc + zs*zsc**2 + 2*zsc**2*z2 + m2*z2c
     &     - zs*zsc*z2c -  2*zsc*z2*z2c
        b(4) = 2*m1*zs*zsc + 2*m2*zs*zsc + 2*m1*zsc*z2 - 2*zs*zsc**2*z2
     &     - zsc**2*z2**2 - m1*zs*z2c - m2*zs*z2c - m2*z2*z2c
     &     + 2*zs*zsc*z2*z2c + zsc*z2**2*z2c
        b(3) =  m1**2*zs + 2*m1*m2*zs + m2**2*zs - m1*m2*z2 - m2**2*z2
     &     - 4*m1*zs*zsc*z2 - 2*m2*zs*zsc*z2 - m1*zsc*z2**2
     &     + m2*zsc*z2**2 + zs*zsc**2*z2**2 + 2*m1*zs*z2*z2c
     &     + m2*zs*z2*z2c - zs*zsc*z2**2*z2c
        b(2) = -2*m1**2*zs*z2 - 2*m1*m2*zs*z2 + m1*m2*z2**2
     &     + 2*m1*zs*zsc*z2**2 - m1*zs*z2**2*z2c
        b(1) = m1**2*zs*z2**2
c
c       solve the polynomial equation, see Numerical Recipies

        call zroots(b, m, roots, .true.)
c
c       check whether the solution is a real solution of the lens equation

        mag = 0.0d0
        nr = 0
        do i=1, m
           z = roots(i)
           zc = dconjg(z)
c           write(6, *) i, roots(i)+dcmplx(x1, y1)
           delta = zs-z+m1/zc + m2/(zc - z2c)
c
c          real solution, calcbulate the magnification
c          real solution, calcbulate the magnification

           if (cdabs(delta) .lt. eps) then
                nr = nr + 1
                dzs = m1/z**2+m2/(z-z2)**2
                mag = mag + 1.0/cdabs(1.0 - dzs*dconjg(dzs))
           endif
        enddo

        return
        end

        function amp(u)
         implicit none
         real*8 amp,u
         amp=(u**2+2.d0)/(u*sqrt(u**2+4.d0))
        end

      SUBROUTINE zroots(a,m,roots,polish)
      INTEGER m,MAXM
      REAL*8 EPS
      DOUBLE COMPLEX a(m+1),roots(m)
      LOGICAL polish
      PARAMETER (EPS=1.d-10,MAXM=101)
CU    USES laguer
      INTEGER i,j,jj,its
      DOUBLE COMPLEX ad(MAXM),x,b,c
      do 11 j=1,m+1
        ad(j)=a(j)
11    continue
      do 13 j=m,1,-1
        x=dcmplx(0.d0,0.d0)
        call laguer(ad,j,x,its)
        if(dabs(dimag(x)).le.2.d0*EPS**2*dabs(dreal(x)))
     &          x=dcmplx(dble(x),0.d0)
        roots(j)=x
        b=ad(j+1)
        do 12 jj=j,1,-1
          c=ad(jj)
          ad(jj)=b
          b=x*b+c
12      continue
13    continue
      if (polish) then
        do 14 j=1,m
          call laguer(a,m,roots(j),its)
14      continue
      endif
      do 16 j=2,m
        x=roots(j)
        do 15 i=j-1,1,-1
          if(dreal(roots(i)).le.dreal(x))goto 10
          roots(i+1)=roots(i)
15      continue
        i=0
10      roots(i+1)=x
16    continue
      return
      END

      SUBROUTINE laguer(a,m,x,its)
      INTEGER m,its,MAXIT,MR,MT
      REAL*8 EPSS
      DOUBLE COMPLEX a(m+1),x
      PARAMETER (EPSS=1.d-10,MR=8,MT=10,MAXIT=MT*MR)
      INTEGER iter,j
      DOUBLE PRECISION abx,abp,abm,err,frac(MR)
      DOUBLE COMPLEX dx,x1,b,d,f,g,h,sq,gp,gm,g2
      SAVE frac
      DATA frac /.5,.25,.75,.13,.38,.62,.88,1./
      do 12 iter=1,MAXIT
        its=iter
        b=a(m+1)
        err=cdabs(b)
        d=dcmplx(0.d0,0.d0)
        f=dcmplx(0.d0,0.d0)
        abx=cdabs(x)
        do 11 j=m,1,-1
          f=x*f+d
          d=x*d+b
          b=x*b+a(j)
          err=cdabs(b)+abx*err
11      continue
        err=EPSS*err
        if(cdabs(b).le.err) then
          return
        else
          g=d/b
          g2=g*g
          h=g2-2.d0*f/b
          sq=cdsqrt((m-1)*(m*h-g2))
          gp=g+sq
          gm=g-sq
          abp=cdabs(gp)
          abm=cdabs(gm)
          if(abp.lt.abm) gp=gm
          if (max(abp,abm).gt.0.d0) then
            dx=m/gp
          else
            dx=cdexp(dcmplx(dlog(1.0d0+abx),dble(iter)))
          endif
        endif
        x1=x-dx
        if(x.eq.x1)return
        if (mod(iter,MT).ne.0) then
          x=x1
        else
          x=x-dx*frac(iter/MT)
        endif
12    continue
      pause 'too many iterations in laguer'
      return
      END   

   

